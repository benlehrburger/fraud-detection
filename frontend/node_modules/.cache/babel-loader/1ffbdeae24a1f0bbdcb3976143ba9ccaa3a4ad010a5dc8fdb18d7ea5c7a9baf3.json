{"ast":null,"code":"// Use relative URLs in development (React proxy) and configurable URL in production\nconst API_BASE_URL = process.env.NODE_ENV === 'production' ? process.env.REACT_APP_API_URL || '/api' : '';\nclass ApiError extends Error {\n  constructor(message, status, response) {\n    super(message);\n    this.status = status;\n    this.response = response;\n    this.name = 'ApiError';\n  }\n}\nclass ApiService {\n  constructor(baseUrl = API_BASE_URL) {\n    this.baseUrl = void 0;\n    this.baseUrl = baseUrl;\n  }\n  async request(endpoint, options = {}) {\n    const url = `${this.baseUrl}${endpoint}`;\n    const defaultOptions = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      }\n    };\n    const config = {\n      ...defaultOptions,\n      ...options\n    };\n    try {\n      const response = await fetch(url, config);\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new ApiError(errorData.error || `HTTP ${response.status}: ${response.statusText}`, response.status, errorData);\n      }\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        return await response.json();\n      }\n      return response.text();\n    } catch (error) {\n      if (error instanceof ApiError) {\n        throw error;\n      }\n\n      // Network or other errors\n      throw new ApiError(error instanceof Error ? error.message : 'Network error occurred', 0);\n    }\n  }\n\n  // Health check\n  async healthCheck() {\n    return this.request('/health');\n  }\n\n  // Transaction endpoints\n  async fetchTransactions(params) {\n    const searchParams = new URLSearchParams();\n    if (params !== null && params !== void 0 && params.page) searchParams.append('page', params.page.toString());\n    if (params !== null && params !== void 0 && params.per_page) searchParams.append('per_page', params.per_page.toString());\n    if (params !== null && params !== void 0 && params.risk_level) searchParams.append('risk_level', params.risk_level);\n    const queryString = searchParams.toString();\n    const endpoint = `/api/transactions${queryString ? `?${queryString}` : ''}`;\n    return this.request(endpoint);\n  }\n  async analyzeTransaction(transactionData) {\n    return this.request('/api/transactions', {\n      method: 'POST',\n      body: JSON.stringify(transactionData)\n    });\n  }\n  async analyzeBatchTransactions(transactions) {\n    return this.request('/api/transactions/batch', {\n      method: 'POST',\n      body: JSON.stringify({\n        transactions\n      })\n    });\n  }\n\n  // Alert endpoints\n  async fetchAlerts(params) {\n    const searchParams = new URLSearchParams();\n    if (params !== null && params !== void 0 && params.severity) searchParams.append('severity', params.severity);\n    if (params !== null && params !== void 0 && params.limit) searchParams.append('limit', params.limit.toString());\n    const queryString = searchParams.toString();\n    const endpoint = `/api/alerts${queryString ? `?${queryString}` : ''}`;\n    return this.request(endpoint);\n  }\n\n  // Statistics endpoint\n  async fetchStatistics() {\n    return this.request('/api/stats');\n  }\n\n  // ML Model endpoints\n  async getModelInfo() {\n    return this.request('/api/model/info');\n  }\n  async trainModel(trainingData) {\n    return this.request('/api/model/train', {\n      method: 'POST',\n      body: trainingData ? JSON.stringify(trainingData) : undefined\n    });\n  }\n\n  // Utility methods with retry logic\n  async testConnection(maxRetries = 3) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        await this.healthCheck();\n        return true;\n      } catch (error) {\n        console.warn(`Connection attempt ${attempt}/${maxRetries} failed:`, error);\n        if (attempt < maxRetries) {\n          // Exponential backoff: 1s, 2s, 4s\n          const delay = Math.pow(2, attempt - 1) * 1000;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    return false;\n  }\n\n  // Service discovery - check multiple possible backend URLs\n  async discoverService() {\n    const possibleUrls = ['',\n    // Current origin (proxy)\n    'http://localhost:5001', 'http://localhost:5000', 'http://127.0.0.1:5001', 'http://127.0.0.1:5000'];\n    for (const url of possibleUrls) {\n      try {\n        const testService = new ApiService(url);\n        const isHealthy = await testService.testConnection(1);\n        if (isHealthy) {\n          console.log(`Service discovered at: ${url || 'current origin'}`);\n          return url;\n        }\n      } catch {\n        // Continue to next URL\n      }\n    }\n    return null;\n  }\n\n  // Real-time updates (WebSocket simulation with polling)\n  startPolling(callback, interval = 5000) {\n    const poll = async () => {\n      try {\n        const response = await this.fetchTransactions({\n          per_page: 50\n        });\n        callback(response.transactions);\n      } catch (error) {\n        console.error('Polling error:', error);\n      }\n    };\n\n    // Initial fetch\n    poll();\n\n    // Set up interval\n    const intervalId = setInterval(poll, interval);\n\n    // Return cleanup function\n    return () => clearInterval(intervalId);\n  }\n\n  // Generate demo transaction for testing\n  generateDemoTransaction() {\n    const merchants = ['Amazon.com', 'Starbucks Coffee', 'Shell Gas Station', 'Walmart Supercenter', 'McDonald\\'s', 'Target Store', 'CVS Pharmacy', 'Home Depot', 'Uber Technologies', 'Netflix.com'];\n    const locations = ['New York, NY, US', 'Los Angeles, CA, US', 'Chicago, IL, US', 'Houston, TX, US', 'Phoenix, AZ, US', 'Philadelphia, PA, US', 'San Antonio, TX, US', 'San Diego, CA, US', 'Dallas, TX, US', 'San Jose, CA, US'];\n    const cardNumbers = ['****1234', '****5678', '****9012', '****3456', '****7890'];\n    return {\n      id: `TXN_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      amount: Math.round((Math.random() * 500 + 10) * 100) / 100,\n      merchant: merchants[Math.floor(Math.random() * merchants.length)],\n      location: locations[Math.floor(Math.random() * locations.length)],\n      timestamp: new Date().toISOString(),\n      card_number: cardNumbers[Math.floor(Math.random() * cardNumbers.length)]\n    };\n  }\n\n  // Batch demo transaction generation\n  generateDemoTransactions(count = 10) {\n    return Array.from({\n      length: count\n    }, () => this.generateDemoTransaction());\n  }\n}\n\n// Create and export singleton instance\nexport const apiService = new ApiService();\n\n// Export individual functions for convenience\nexport const {\n  healthCheck,\n  fetchTransactions,\n  analyzeTransaction,\n  analyzeBatchTransactions,\n  fetchAlerts,\n  fetchStatistics,\n  getModelInfo,\n  trainModel,\n  testConnection,\n  startPolling,\n  generateDemoTransaction,\n  generateDemoTransactions\n} = apiService;\n\n// Export error class\nexport { ApiError };\n\n// Default export\nexport default apiService;","map":{"version":3,"names":["API_BASE_URL","process","env","NODE_ENV","REACT_APP_API_URL","ApiError","Error","constructor","message","status","response","name","ApiService","baseUrl","request","endpoint","options","url","defaultOptions","headers","config","fetch","ok","errorData","json","catch","error","statusText","contentType","get","includes","text","healthCheck","fetchTransactions","params","searchParams","URLSearchParams","page","append","toString","per_page","risk_level","queryString","analyzeTransaction","transactionData","method","body","JSON","stringify","analyzeBatchTransactions","transactions","fetchAlerts","severity","limit","fetchStatistics","getModelInfo","trainModel","trainingData","undefined","testConnection","maxRetries","attempt","console","warn","delay","Math","pow","Promise","resolve","setTimeout","discoverService","possibleUrls","testService","isHealthy","log","startPolling","callback","interval","poll","intervalId","setInterval","clearInterval","generateDemoTransaction","merchants","locations","cardNumbers","id","Date","now","random","substr","amount","round","merchant","floor","length","location","timestamp","toISOString","card_number","generateDemoTransactions","count","Array","from","apiService"],"sources":["/Users/benlehrburger/Desktop/fintechco-fraud-detection/frontend/src/services/api.ts"],"sourcesContent":["// Use relative URLs in development (React proxy) and configurable URL in production\nconst API_BASE_URL = process.env.NODE_ENV === 'production' \n  ? (process.env.REACT_APP_API_URL || '/api')\n  : '';\n\nexport interface Transaction {\n  transaction_id: string;\n  timestamp: string;\n  amount: number;\n  merchant: string;\n  location: string;\n  card_number: string;\n  fraud_analysis?: {\n    risk_score: number;\n    risk_level: string;\n    factors: string[];\n  };\n  risk_analysis?: {\n    risk_score: number;\n    risk_level: string;\n    confidence: number;\n    recommendations: string[];\n    factors: Array<{\n      name: string;\n      weight: number;\n      value: number;\n      description: string;\n    }>;\n  };\n  final_decision?: {\n    final_risk_score: number;\n    action: string;\n    reason: string;\n    confidence: number;\n  };\n  ml_prediction?: {\n    fraud_probability: number;\n    combined_fraud_probability: number;\n    is_anomaly: boolean;\n    top_risk_factors?: Array<{\n      feature: string;\n      value: number;\n      contribution: number;\n    }>;\n  };\n  validation_warnings?: string[];\n}\n\nexport interface Alert {\n  id: string;\n  transaction_id: string;\n  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';\n  risk_score: number;\n  action_required: string;\n  reason: string;\n  merchant: string;\n  amount: number;\n  location: string;\n  created_at: string;\n  status: 'OPEN' | 'INVESTIGATING' | 'RESOLVED' | 'FALSE_POSITIVE';\n}\n\nexport interface Statistics {\n  total_transactions: number;\n  fraud_rate: number;\n  risk_distribution: Record<string, number>;\n  alerts_count: number;\n  model_status: 'trained' | 'not_trained';\n}\n\nexport interface ModelInfo {\n  status: 'trained' | 'not_trained';\n  feature_count?: number;\n  features?: string[];\n  anomaly_model?: string;\n  has_supervised_model?: boolean;\n  supervised_model?: string;\n  n_estimators?: number;\n  feature_importance?: Record<string, number>;\n}\n\nexport interface ApiResponse<T> {\n  data?: T;\n  error?: string;\n  message?: string;\n}\n\nexport interface PaginatedResponse<T> {\n  data: T[];\n  pagination: {\n    page: number;\n    per_page: number;\n    total: number;\n    pages: number;\n  };\n}\n\nclass ApiError extends Error {\n  constructor(\n    message: string,\n    public status: number,\n    public response?: any\n  ) {\n    super(message);\n    this.name = 'ApiError';\n  }\n}\n\nclass ApiService {\n  protected baseUrl: string;\n\n  constructor(baseUrl: string = API_BASE_URL) {\n    this.baseUrl = baseUrl;\n  }\n\n  protected async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const defaultOptions: RequestInit = {\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers,\n      },\n    };\n\n    const config = { ...defaultOptions, ...options };\n\n    try {\n      const response = await fetch(url, config);\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new ApiError(\n          errorData.error || `HTTP ${response.status}: ${response.statusText}`,\n          response.status,\n          errorData\n        );\n      }\n\n      const contentType = response.headers.get('content-type');\n      if (contentType && contentType.includes('application/json')) {\n        return await response.json();\n      }\n      \n      return response.text() as unknown as T;\n    } catch (error) {\n      if (error instanceof ApiError) {\n        throw error;\n      }\n      \n      // Network or other errors\n      throw new ApiError(\n        error instanceof Error ? error.message : 'Network error occurred',\n        0\n      );\n    }\n  }\n\n  // Health check\n  async healthCheck(): Promise<{\n    status: string;\n    timestamp: string;\n    services: Record<string, string>;\n  }> {\n    return this.request('/health');\n  }\n\n  // Transaction endpoints\n  async fetchTransactions(params?: {\n    page?: number;\n    per_page?: number;\n    risk_level?: string;\n  }): Promise<{\n    transactions: Transaction[];\n    pagination: {\n      page: number;\n      per_page: number;\n      total: number;\n      pages: number;\n    };\n  }> {\n    const searchParams = new URLSearchParams();\n    \n    if (params?.page) searchParams.append('page', params.page.toString());\n    if (params?.per_page) searchParams.append('per_page', params.per_page.toString());\n    if (params?.risk_level) searchParams.append('risk_level', params.risk_level);\n\n    const queryString = searchParams.toString();\n    const endpoint = `/api/transactions${queryString ? `?${queryString}` : ''}`;\n    \n    return this.request(endpoint);\n  }\n\n  async analyzeTransaction(transactionData: {\n    id: string;\n    amount: number | string;\n    merchant: string;\n    location: string;\n    timestamp: string;\n    card_number: string;\n    currency?: string;\n    description?: string;\n  }): Promise<Transaction> {\n    return this.request('/api/transactions', {\n      method: 'POST',\n      body: JSON.stringify(transactionData),\n    });\n  }\n\n  async analyzeBatchTransactions(transactions: Array<{\n    id: string;\n    amount: number | string;\n    merchant: string;\n    location: string;\n    timestamp: string;\n    card_number: string;\n    currency?: string;\n    description?: string;\n  }>): Promise<{\n    results: Array<Transaction | { error: string; transaction_index: number }>;\n    summary: {\n      total_processed: number;\n      successful: number;\n      failed: number;\n      validation_summary: any;\n    };\n  }> {\n    return this.request('/api/transactions/batch', {\n      method: 'POST',\n      body: JSON.stringify({ transactions }),\n    });\n  }\n\n  // Alert endpoints\n  async fetchAlerts(params?: {\n    severity?: string;\n    limit?: number;\n  }): Promise<{\n    alerts: Alert[];\n    total_count: number;\n  }> {\n    const searchParams = new URLSearchParams();\n    \n    if (params?.severity) searchParams.append('severity', params.severity);\n    if (params?.limit) searchParams.append('limit', params.limit.toString());\n\n    const queryString = searchParams.toString();\n    const endpoint = `/api/alerts${queryString ? `?${queryString}` : ''}`;\n    \n    return this.request(endpoint);\n  }\n\n  // Statistics endpoint\n  async fetchStatistics(): Promise<Statistics> {\n    return this.request('/api/stats');\n  }\n\n  // ML Model endpoints\n  async getModelInfo(): Promise<ModelInfo> {\n    return this.request('/api/model/info');\n  }\n\n  async trainModel(trainingData?: {\n    transactions: any[];\n    labels: number[];\n  }): Promise<{\n    status: string;\n    message: string;\n    training_results: any;\n  }> {\n    return this.request('/api/model/train', {\n      method: 'POST',\n      body: trainingData ? JSON.stringify(trainingData) : undefined,\n    });\n  }\n\n  // Utility methods with retry logic\n  async testConnection(maxRetries: number = 3): Promise<boolean> {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        await this.healthCheck();\n        return true;\n      } catch (error) {\n        console.warn(`Connection attempt ${attempt}/${maxRetries} failed:`, error);\n        if (attempt < maxRetries) {\n          // Exponential backoff: 1s, 2s, 4s\n          const delay = Math.pow(2, attempt - 1) * 1000;\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n    return false;\n  }\n\n  // Service discovery - check multiple possible backend URLs\n  async discoverService(): Promise<string | null> {\n    const possibleUrls = [\n      '', // Current origin (proxy)\n      'http://localhost:5001',\n      'http://localhost:5000',\n      'http://127.0.0.1:5001',\n      'http://127.0.0.1:5000'\n    ];\n\n    for (const url of possibleUrls) {\n      try {\n        const testService = new ApiService(url);\n        const isHealthy = await testService.testConnection(1);\n        if (isHealthy) {\n          console.log(`Service discovered at: ${url || 'current origin'}`);\n          return url;\n        }\n      } catch {\n        // Continue to next URL\n      }\n    }\n    \n    return null;\n  }\n\n  // Real-time updates (WebSocket simulation with polling)\n  startPolling(\n    callback: (transactions: Transaction[]) => void,\n    interval: number = 5000\n  ): () => void {\n    const poll = async () => {\n      try {\n        const response = await this.fetchTransactions({ per_page: 50 });\n        callback(response.transactions);\n      } catch (error) {\n        console.error('Polling error:', error);\n      }\n    };\n\n    // Initial fetch\n    poll();\n    \n    // Set up interval\n    const intervalId = setInterval(poll, interval);\n    \n    // Return cleanup function\n    return () => clearInterval(intervalId);\n  }\n\n  // Generate demo transaction for testing\n  generateDemoTransaction(): {\n    id: string;\n    amount: number;\n    merchant: string;\n    location: string;\n    timestamp: string;\n    card_number: string;\n  } {\n    const merchants = [\n      'Amazon.com',\n      'Starbucks Coffee',\n      'Shell Gas Station',\n      'Walmart Supercenter',\n      'McDonald\\'s',\n      'Target Store',\n      'CVS Pharmacy',\n      'Home Depot',\n      'Uber Technologies',\n      'Netflix.com'\n    ];\n\n    const locations = [\n      'New York, NY, US',\n      'Los Angeles, CA, US',\n      'Chicago, IL, US',\n      'Houston, TX, US',\n      'Phoenix, AZ, US',\n      'Philadelphia, PA, US',\n      'San Antonio, TX, US',\n      'San Diego, CA, US',\n      'Dallas, TX, US',\n      'San Jose, CA, US'\n    ];\n\n    const cardNumbers = [\n      '****1234',\n      '****5678',\n      '****9012',\n      '****3456',\n      '****7890'\n    ];\n\n    return {\n      id: `TXN_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      amount: Math.round((Math.random() * 500 + 10) * 100) / 100,\n      merchant: merchants[Math.floor(Math.random() * merchants.length)],\n      location: locations[Math.floor(Math.random() * locations.length)],\n      timestamp: new Date().toISOString(),\n      card_number: cardNumbers[Math.floor(Math.random() * cardNumbers.length)]\n    };\n  }\n\n  // Batch demo transaction generation\n  generateDemoTransactions(count: number = 10): Array<{\n    id: string;\n    amount: number;\n    merchant: string;\n    location: string;\n    timestamp: string;\n    card_number: string;\n  }> {\n    return Array.from({ length: count }, () => this.generateDemoTransaction());\n  }\n}\n\n// Create and export singleton instance\nexport const apiService = new ApiService();\n\n// Export individual functions for convenience\nexport const {\n  healthCheck,\n  fetchTransactions,\n  analyzeTransaction,\n  analyzeBatchTransactions,\n  fetchAlerts,\n  fetchStatistics,\n  getModelInfo,\n  trainModel,\n  testConnection,\n  startPolling,\n  generateDemoTransaction,\n  generateDemoTransactions\n} = apiService;\n\n// Export error class\nexport { ApiError };\n\n// Default export\nexport default apiService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}